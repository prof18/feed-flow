name: Windows Release

on:
  workflow_call:
    secrets:
      GRADLE_CACHE_ENCRYPTION_KEY:
        required: true
      DROPBOX_API_KEY:
        required: true
      SENTRY_DNS:
        required: true
      MSIX_PUBLISHER_DISPLAY_NAME:
        required: true
      TDECK_SALT:
        required: true
      TDECK_APP_ID:
        required: true

jobs:
  deploy:
    runs-on: windows-latest
    timeout-minutes: 40
    outputs:
      release_path: ${{ steps.path_variables.outputs.release_path }}
      artifact_name: ${{ steps.path_variables.outputs.artifact_name }}
      release_path_msix: ${{ steps.path_variables.outputs.release_path_msix }}
      name_msix: ${{ steps.path_variables.outputs.name_msix }}

    steps:
      - uses: actions/checkout@v5

      - name: Setup environment
        uses: ./.github/actions/setup-gradle
        with:
          gradle-cache-encryption-key: ${{ secrets.GRADLE_CACHE_ENCRYPTION_KEY }}

      - name: Read version from properties
        id: version
        shell: pwsh
        run: |
          $MAJOR = (Get-Content version.properties | Select-String "MAJOR=").ToString().Split("=")[1]
          $MINOR = (Get-Content version.properties | Select-String "MINOR=").ToString().Split("=")[1]
          $PATCH = (Get-Content version.properties | Select-String "PATCH=").ToString().Split("=")[1]
          $VERSION = "$MAJOR.$MINOR.$PATCH"
          "version=$VERSION" >> $env:GITHUB_OUTPUT
          "VERSION=$VERSION" >> $env:GITHUB_ENV

      - name: Update Licenses file
        run: ./gradlew desktopApp:exportLibraryDefinitions "-PaboutLibraries.exportPath=src/main/resources/"

      - name: Create path variables
        id: path_variables
        shell: pwsh
        run: |
          $name = "FeedFlow-$env:VERSION.msi"
          $path = "desktopApp/build/release/main-release/msi/${name}"
          $name_msix = "FeedFlow-$env:VERSION.msix"
          $path_msix = "desktopApp/build/release/main-release/msix/${name_msix}"
          "release_path=$path" >> $env:GITHUB_OUTPUT
          "artifact_name=$name" >> $env:GITHUB_OUTPUT
          "release_path_msix=$path_msix" >> $env:GITHUB_OUTPUT
          "name_msix=$name_msix" >> $env:GITHUB_OUTPUT
          "RELEASE_PATH=$path" >> $env:GITHUB_ENV
          "ARTIFACT_NAME=$name" >> $env:GITHUB_ENV
          "RELEASE_PATH_MSIX=$path_msix" >> $env:GITHUB_ENV
          "NAME_MSIX=$name_msix" >> $env:GITHUB_ENV
        env:
          VERSION: ${{ steps.version.outputs.version }}

      - name: Create Properties file
        shell: pwsh
        run: |
          "is_release=true" >> desktopApp/src/jvmMain/resources/props.properties
          "sentry_dns=$env:SENTRY_DNS" >> desktopApp/src/jvmMain/resources/props.properties
          "version=$env:VERSION" >> desktopApp/src/jvmMain/resources/props.properties
          "dropbox_key=$env:DROPBOX_API_KEY" >> desktopApp/src/jvmMain/resources/props.properties
          "tdeck_app_id=$env:DROPBOX_API_KEY" >> desktopApp/src/jvmMain/resources/props.properties
          "tdeck_salt=$env:DROPBOX_API_KEY" >> desktopApp/src/jvmMain/resources/props.properties
        env:
          SENTRY_DNS: ${{ secrets.SENTRY_DNS }}
          VERSION: ${{ steps.version.outputs.version }}
          DROPBOX_API_KEY: ${{ secrets.DROPBOX_API_KEY }}
          TDECK_SALT: ${{ secrets.TDECK_SALT }}
          TDECK_APP_ID: ${{ secrets.TDECK_APP_ID }}

      - name: Create MSI
        run: ./gradlew packageReleaseMsi

      - name: Convert MSI to MSIX
        shell: pwsh
        run: |
          Write-Host "Starting manual MSI to MSIX conversion..."

          # Create directories
          $extractDir = "msix_extract"
          $msixDir = "desktopApp/build/release/main-release/msix"
          New-Item -ItemType Directory -Force -Path $extractDir | Out-Null
          New-Item -ItemType Directory -Force -Path $msixDir | Out-Null

          # Extract MSI contents
          Write-Host "Extracting MSI contents..."
          $msiPath = (Resolve-Path $env:RELEASE_PATH).Path
          $extractPath = (Resolve-Path $extractDir).Path

          $proc = Start-Process -FilePath "msiexec.exe" -ArgumentList "/a", "`"$msiPath`"", "/qn", "TARGETDIR=`"$extractPath`"" -Wait -PassThru
          if ($proc.ExitCode -ne 0) {
            Write-Error "MSI extraction failed with exit code $($proc.ExitCode)"
            exit 1
          }

          Write-Host "MSI extraction completed successfully"

          # Find the FeedFlow installation directory
          $feedFlowDir = Get-ChildItem -Path $extractDir -Recurse -Directory -Filter "FeedFlow*" | Select-Object -First 1
          if (-not $feedFlowDir) {
            Write-Error "Could not find FeedFlow directory in extracted MSI"
            Write-Host "Contents of extract directory:"
            Get-ChildItem -Path $extractDir -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          Write-Host "Found FeedFlow directory at: $($feedFlowDir.FullName)"

          # Create MSIX package structure
          $packageRoot = "msix_package"
          New-Item -ItemType Directory -Force -Path $packageRoot | Out-Null

          # Copy application files to package root
          Write-Host "Copying application files..."
          Copy-Item -Path "$($feedFlowDir.FullName)\*" -Destination $packageRoot -Recurse -Force

          # Verify that FeedFlow.exe exists
          if (-not (Test-Path "$packageRoot\FeedFlow.exe")) {
            Write-Error "FeedFlow.exe not found in package directory"
            Write-Host "Contents of package directory:"
            Get-ChildItem -Path $packageRoot -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          # Create AppxManifest.xml
          Write-Host "Creating AppxManifest.xml..."
          $publisherName = "${{ secrets.MSIX_PUBLISHER_DISPLAY_NAME }}"
          $version = "${{ steps.version.outputs.version }}.0"

          # Load resources template
          [xml]$resourcesTemplate = Get-Content -Path ".github/msix-resources-template.xml"
          $resourcesXml = ""
          foreach ($resource in $resourcesTemplate.Resources.Resource) {
            $resourcesXml += "    <Resource Language=`"$($resource.Language)`" />`n"
          }

          # Build manifest XML
          $manifestContent = '<?xml version="1.0" encoding="utf-8"?>' + "`n"
          $manifestContent += '<Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"' + "`n"
          $manifestContent += '         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"' + "`n"
          $manifestContent += '         xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">' + "`n"
          $manifestContent += '  <Identity Name="MarcoGomiero.FeedFlowRSSReader"' + "`n"
          $manifestContent += "            Publisher=`"$publisherName`"" + "`n"
          $manifestContent += "            Version=`"$version`"" + "`n"
          $manifestContent += '            ProcessorArchitecture="x64" />' + "`n"
          $manifestContent += '  <Properties>' + "`n"
          $manifestContent += '    <DisplayName>FeedFlow - RSS Reader</DisplayName>' + "`n"
          $manifestContent += '    <PublisherDisplayName>Marco Gomiero</PublisherDisplayName>' + "`n"
          $manifestContent += '    <Logo>Assets\StoreLogo.png</Logo>' + "`n"
          $manifestContent += '  </Properties>' + "`n"
          $manifestContent += '  <Dependencies>' + "`n"
          $manifestContent += '    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.22000.1" />' + "`n"
          $manifestContent += '  </Dependencies>' + "`n"
          $manifestContent += '  <Resources>' + "`n"
          $manifestContent += $resourcesXml
          $manifestContent += '  </Resources>' + "`n"
          $manifestContent += '  <Applications>' + "`n"
          $manifestContent += '    <Application Id="FeedFlow" Executable="FeedFlow.exe" EntryPoint="Windows.FullTrustApplication">' + "`n"
          $manifestContent += '      <uap:VisualElements DisplayName="FeedFlow - RSS Reader"' + "`n"
          $manifestContent += '                          Description="A modern RSS reader"' + "`n"
          $manifestContent += '                          BackgroundColor="transparent"' + "`n"
          $manifestContent += '                          Square150x150Logo="Assets\Square150x150Logo.png"' + "`n"
          $manifestContent += '                          Square44x44Logo="Assets\Square44x44Logo.png">' + "`n"
          $manifestContent += '      </uap:VisualElements>' + "`n"
          $manifestContent += '    </Application>' + "`n"
          $manifestContent += '  </Applications>' + "`n"
          $manifestContent += '  <Capabilities>' + "`n"
          $manifestContent += '    <rescap:Capability Name="runFullTrust" />' + "`n"
          $manifestContent += '    <Capability Name="internetClient" />' + "`n"
          $manifestContent += '  </Capabilities>' + "`n"
          $manifestContent += '</Package>'

          [System.IO.File]::WriteAllText("$packageRoot\AppxManifest.xml", $manifestContent, [System.Text.Encoding]::UTF8)

          # Create Assets folder with placeholder images
          $assetsDir = "$packageRoot\Assets"
          New-Item -ItemType Directory -Force -Path $assetsDir | Out-Null

          # Create simple placeholder PNG files (1x1 transparent pixel)
          $pngBytes = [Convert]::FromBase64String("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==")
          [System.IO.File]::WriteAllBytes("$assetsDir\StoreLogo.png", $pngBytes)
          [System.IO.File]::WriteAllBytes("$assetsDir\Square150x150Logo.png", $pngBytes)
          [System.IO.File]::WriteAllBytes("$assetsDir\Square44x44Logo.png", $pngBytes)

          # Package using makeappx
          Write-Host "Packaging MSIX..."
          $makeAppxPath = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\makeappx.exe"
          & $makeAppxPath pack /d $packageRoot /p $env:RELEASE_PATH_MSIX /nv

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create MSIX package"
            exit 1
          }

          Write-Host "MSIX package created successfully at: $env:RELEASE_PATH_MSIX"

          # Cleanup
          Remove-Item -Path $extractDir -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path $packageRoot -Recurse -Force -ErrorAction SilentlyContinue

      - name: Upload reports
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: reports
          path: |
            **/build/compose/logs/*  

      - name: Upload MSI asset
        if: always()
        uses: actions/upload-artifact@v4
        with:
          path: ${{ env.RELEASE_PATH }}
          name: ${{ env.ARTIFACT_NAME }}
          retention-days: 7

      - name: Upload MSIX asset
        uses: actions/upload-artifact@v4
        with:
          path: ${{ env.RELEASE_PATH_MSIX }}
          name: ${{ env.NAME_MSIX }}
          retention-days: 7 